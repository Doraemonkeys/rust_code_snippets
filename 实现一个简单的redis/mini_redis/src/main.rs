fn main() {
    println!("Hello, world!");
}

// 虽然 tokio 对于大多数需要并发的项目都是非常适合的，但是确实有一些场景它并不适合使用:
// - 并行运行 CPU 密集型的任务。tokio 非常适合于 IO 密集型任务，
//   这些 IO 任务的绝大多数时间都用于阻塞等待 IO 的结果，而不是刷刷刷的单烤 CPU。
//   如果你的应用是 CPU 密集型(例如并行计算)，建议使用 rayon，
//   当然，对于其中的 IO 任务部分，你依然可以混用 tokio
// - 读取大量的文件。读取文件的瓶颈主要在于操作系统，因为 OS 没有提供异步文件读取接口，
//   大量的并发并不会提升文件读取的并行性能，反而可能会造成不可忽视的性能损耗，
//   因此建议使用线程(或线程池)的方式
// - 发送少量 HTTP 请求。tokio 的优势是给予你并发处理大量任务的能力，
//   对于这种轻量级 HTTP 请求场景，tokio 除了增加你的代码复杂性，并无法带来什么额外的优势。
//   因此，对于这种场景，你可以使用 reqwest库，它会更加简单易用。

// 若大家使用 tokio，那 CPU 密集的任务尤其需要用线程的方式去处理，
// 例如使用 spawn_blocking 创建一个阻塞的线程去完成相应 CPU 密集任务。
// 原因是：tokio 是协作式的调度器，如果某个 CPU 密集的异步任务是通过 tokio 创建的，
// 那理论上来说，该异步任务需要跟其它的异步任务交错执行，最终大家都得到了执行，皆大欢喜。
// 但实际情况是，CPU 密集的任务很可能会一直霸着着 CPU，此时 tokio 的调度方式决定了该任务会一直被执行，
// 这意味着，其它的异步任务无法得到执行的机会，最终这些任务都会因为得不到资源而饿死。
// 而使用 spawn_blocking 后，会创建一个单独的 OS 线程，该线程并不会被 tokio 所调度( 被 OS 所调度 )，
// 因此它所执行的 CPU 密集任务也不会导致 tokio 调度的那些异步任务被饿死
